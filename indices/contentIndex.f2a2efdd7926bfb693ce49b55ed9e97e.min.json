{"/":{"title":"Appunti TPI","content":"\n## Lista argomenti\n- [x] [[notes/Elaborazione concorrente|Elaborazione concorrente]]\n\t- [x] Generalità.\n- [x] [[notes/Descrizione della concorrenza|Descrizione della concorrenza]]:\n\t- [x] Esecuzione parallela;\n\t- [x] fork-join;\n\t- [x] cobegin-coend\n- [x] [[notes/La comunicazione tra processi|La comunicazione tra processi]]:\n\t- [x] Introduzione;\n\t- [x] Modello a memoria comune;\n\t- [x] Modello a scambio di messaggi\n- [x] [[notes/Sincronizzazione tra processi|Sincronizzazione tra processi]]:\n\t- [x] Errori nei programmi concorrenti;\n\t- [x] Mutua Esclusione e sezione critica;\n\t- [x] Starvation e deadlock;\n- [x] [[notes/Semafori|Semafori]]:\n\t- [x] Premessa;\n\t- [x] Semafori di basso livello e spinlock;\n\t- [x] Semaforo di Dijkstra;\n","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/New-Vault/Bancomat-Galeotto":{"title":"Bancomat Galeotto","content":"Sonja è una donna di Albuquerque, che ogni sera, tornando a casa dal lavoro, si ferma davanti al solito bancomat per prelevare 20 dollari. Una sera qualsiasi però, mentre prelevava i 20 dollari Sonja sentì una voce dietro di se che le dice di darle tutti i suoi soldi, nonostante ciò lei non fu sorpresa ma anzi se lo aspettava. Sonja aspettò che i rumori del bancomat finissero, per poi girarsi verso il rapinatore senza però guardarlo in faccia, perché aveva letto che egli poteva ucciderla essendo identificato. Sonja allora diede i soldi al rapinatore, ma egli lo fermò chiedendone altri 20, allora Sonja non resistendo alla sua voglia di guardare il rapinatore alzò lo sguardo e vide un piccolo e giovane uomo dall'aspetto cosi triste e innocente che nemmeno la canna dell'arma che puntava a Sonja dal taschino riusciva a far paura. La donna quindi, dopo la richiesta del rapinatore capì che egli non era un professionista, ma solo un ragazzo ancor più bisognoso di lei, e si rese conto anche che quella pistola che nascondeva nel taschino era solo una bottiglietta di vodka. Sonja decise quindi di non dare neanche un dollaro al rapinatore, bensì lo fece salire sulla macchina di lei, promettendogli che gli avrebbe comprato un hamburger. Si diresse quindi a un fast-food, dove mangiarono insieme un hamburger mentre parlarono. Mangiarono 20 dollari in hamburger, non per fame ma solo per parlare, lui le raccontò la sua storia banale, triste e fallimentare, Sonja gli raccontò la sua storia, ugualmente banale, triste e fallimentare. I due capirono di avere molto in comune. Dopo aver finito di mangiare, Sonja disse al rapinatore, di nome Bob di salire in macchina con lei. Chiese a Sonja dove fossero diretti, ma lei non rispose. Arrivati a destinazione, Bob fu sorpreso di trovarsi davanti a una stazione di polizia, cercò di ribellarsi ma Sonja gli disse che se sapesse cosa fare allora lei lo avrebbe aspettato. Bob allora decise di farsi arrestare, sapendo di avere un mandato di cattura per vari crimini. Dopo un solo anno Bob uscì dal carcere, sorpreso di vedere davanti al portone proprio Sonja, che lo aspettò davvero. Invitò Bob ad andare a mangiare un Hamburger, e un mese dopo già si sposarono.","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/New-Vault/TPI/Il-Cablaggio-strutturato":{"title":"Il Cablaggio strutturato","content":"Il cablaggio è la realizzazione di impianti che permettono la comunicazione\nL'impianto di comunicazione deve seguire delle norme. \nle norme che regolano il cablaggio sono le seguenti:\nLo standard EIA/TIA-568\nLo standard EIA/TIA-578\nLo standard ISO/IEC DIS \n\nLa topologia del cablaggio è di tipo gerarchico, si possono individuare tre livelli nella gerarchia:\n- Il centro stella del comprensorio detto anche MC, è unico per comprensorio;\n- Il centro stella di edificio detto IC;\n- Armadio di piano detto Telecommunication closet TC;\n\nMC è il permutatore principale situato nell'edificio principale, e da esso partono tutti i cavi di dorsale per i singoli edifici. All'interno di ogni edificio troviamo l'IC e l'armadio di distribuzione presente in ogni edificio del comprensorio e da esso vengono distribuiti i cavi di dorsale di edificio ai vari piani.\n\n","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/New-Vault/TPI/Introduzione-al-multitasking":{"title":"Introduzione al multitasking","content":"Un processo é una sequenza di istruzioni che attivano fasi di elaborazioni della cpu,fasi di attesa per l esecuzione di operazioni su altre risorse del sistema che di fatto lasciano inattiva la cpu\nnei sistemi operativi multitasking durante le fasi di attesa mandano in esecuzione altri programmi tra quelli caricati in memoria, cio riduce al minimo la non operativitá della cpu migliorando cosi l'efficienza del sistema e rendendo possibile un parallelismo tra i processi che in realta é virtuale dato che il processore é unico \nPossiamo fare una distinzione di parallalelismo in\n\n- multitasking: esecuzione di programmi indipendenti sulla CPU e sul processore di I/O\n- multiprocessing: multiprogrammazione estesa a elaboratori dotati di piu CPU e processori di I/O\n\nUn processo é costituito da due parti: \n\n- Il codice\n- I dati del programma\n\nIn particolare i dati del programma si suddividono in:\n- Variabili globali\n- Variabili locali\n- Variabili temporanee\n- Variabili allocate dinamicamente\n\nL'insieme di tutti i dati di un processo prende anche il nome di conesto del processo e varia istante per istante.\nUn processo puo stare in diversi stati \nPer stato di un processo intendiamo la situazione possibile in cui il processo in esecuzione puo trovarsi. In particolare gli stati di un processo sono:\n- Nuovo (New)\n- Esecuzione(running)\n- Attesa (Waiting)\n- Pronto (Ready to run)\n- Fine (Terminated)\nLa descrizione di questi stati avviene mediante il modello diagramma di stato","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/New-Vault/TPI/Storia-dellinternet":{"title":"Storia dell'internet","content":"Nel 1958 nasce la DARPA%%Defense Advanced Research Projects Agency %%, con sede nel Pentagono e fu applicata per ricerche nel campo della comunicazione dell'informazione.\n\n \u003e La DARPA è un agenzia governativa fondata dagli stati uniti per lo sviluppo di tecnologie ad uso militari.\n\nIntorno al 1965 la DARPA iniziava ad avere problemi di gestione per via della mancanza di comunicazione dei vari computer nelle loro sedi.\n\nNel 1966 il direttore della divisione informatica della DARPA %%Bob Taylor%% parló con Carlie Hertzfeld %%direttore della DARPA%%per fondare il progetto ARPANET. \n\nQuesto progetto sarebbe servito a condividere online il tempo di utilizzo del computer tra le diverse sedi della DARPA. \n\nNel 1969 il titolare del laboratorio della UCLA fu incaricato di creare il primo collegamento telefonico da computer a computer, fondando i primi nodi dell'internet.\n\nAd entrambi i computer fu consegnato un IMP, ovvero un computer dedicati alla gestione di traffico dati. Questi 4 nodi furono poi collegati attraverso circuiti a 50Kbps. \n\nIl primo esperimento di collegamento fu fatto dal professor Kleinrock che tentó di accedere in remoto ad un computer di Stanford. \n\n%%Digitó la lettera L, che apparí sullo schermo dell'altro computer, poi la O, che anch'essa apparí sullo schermo e infine la G che fece andare in tilt il sistema. Il secondo tentativo peró andó a buon fine.%%\n\nL'ARPANET ebbe un grande sviluppo, infatti alla fine del 72 aveva ben 37 nodi. \nNel 78, nacque poi l'IP %%Internet Protocol%%che si aggiunse al TCP per finire il protocollo TCP/IP%%TCP per la gestione di pacchetti e IP per la loro canalizzazione%%\n\n","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/notes/Descrizione-della-concorrenza":{"title":"Descrizione della concorrenza","content":"## Esecuzione parallela\nPer eseguire un processo non sequenziale c'è la necessità di utilizzare:\n- Un elaboratore non sequenziale;\n- un linguaggio di programmazione non sequenziale.\n\nL'elaboratore non sequenziale è una macchina che è in grado di eseguire più operazioni contemporaneamente. Distinguiamo tali macchine in sistemi multiprocessori o multielaboratori dove abbiamo il parallelismo fisico, e sistemi monoprocessori multiprogrammati con parallelismo virtuale.\n\nI linguaggi non sequenziali sono i linguaggi di programazione che consentono la programmazione delle attività concorrenti. Tali linguaggi concorrenti, di alto livello, implementano nuove istruzioni come i costrutti **fork-join** e **cobegin-coend**.\n\n### fork-join\nLe istruzioni fork-join servono a descrivere l'esecuzione parallela tramite la scomposizione di due processi e la riunione in un unico processo:\n- L'istruzione fork corrisponde alla biforcazione di un nodo in due rami, quindi la creazione di un processo figlio che inizia l'esecuzione in parallelo con il processo padre;\n- L'istruzione join viene eseguita quando il processo figlio termina la sua esecuzione e si sincronizza con il processo padre.\n\n### cobegin-coend\nLe istruzioni cobegin-coend permettono di indicare un punto in cui più processi iniziano contemporaneamente l'esecuzione (**cobegin**) e il punto in cui terminano, unendosi al processo principale (**coend**).\nI costrutti cobegin-coend sono più semplici da utilizzare e il codice ottenuto è più strutturato e comprensibile, dato che tramite il fork-join trasformiamo il codice in strutture simili ai vecchi linguaggi di programmazione che utilizzavano l'istruzione di salto (**goto**).","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/notes/Elaborazione-concorrente":{"title":"Elaborazione concorrente","content":"## Generalità\n### Elaborazione Sequenziale vs Elaborazione Concorrente\n\nPer elaborazione sequenziale si intende l'esecuzione di un programma sequenziale le cui istruzioni vengano eseguite una dopo l'altra in un determinato ordine, quindi un'operazione deve essere completata prima che inizi una successiva operazione. \n\nPer elaborazione concorrente intendiamo invece le tecniche e strumenti che descrivono il comportamento di processi paralleli, ovvero più processi che vengono eseguiti contemporaneamente.\n\nLa vera elaborazione concorrente si verifica solo quando si è in presenza di architetture multiprocessore, perché, come sappiamo, nei sistemi monoprocessori il parallelismo avviene virtualmente grazie al multitasking.\n\nPossiamo parlare infine di sistema concorrente, ovvero un sistema software che manda avanti l'esecuzione di più processi che possono **cooperare** ad un obiettivo comune o **competere** per utilizzare **risorse condivise**.","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/notes/La-comunicazione-tra-processi":{"title":"La comunicazione tra processi","content":"## Introduzione\nI processi concorrenti interagiscono tra di loro condividendo risorse comuni. Possiamo individuare due modelli di interazione concorrente:\n- Modello a memoria comune;\n- Modello a scambio di messaggi.\n\n### Modello a memoria comune\nIl modello a memoria comune viene utilizzato nelle architetture che usano un' unica memoria comune a tutti i processi, come nel caso delle macchine monoprocessori con processi multitasking, inoltre, il sistema operativo associa ad ogni risorsa un gestore di risorse.\n\n### Modello a scambio di messaggi\nNel caso di un ambiente locale in cui ogni processo ha accesso solo alle risorse allocate nella propria memoria locale, i processi utilizzano lo scambio di messaggi come strumento di comunicazione e sincronizzazione. Questo modello rappresenta un sistema in cui ogni processore ha una memoria privata e opera in un ambiente locale che non è accessibile ad altri processi.\n\nIl modello a scambio di messaggi può essere classificato in vari modi:\n- nel caso di comunicazione asincrona la comunicazione da parte del processo mittente avviene senza che questo rimanga in attesa di una risposta da parte del processo destinatario;  \n- nel caso di comunicazione sincrona lo scambio di informazioni può avvenire solo se mittente e destinatario sono pronti a “parlarsi” e quindi è necessario che si sincronizzino, e questa interazione prende il nome di **rendez-vous**:\n\t- stretto: se si limita alla trasmissione di un messaggio dal mittente al destinatario;\n\t- esteso: se il destinatario, una volta ricevuto il messaggio, deve inviare una risposta al mittente.\n\nPossiamo inoltre distinguere la comunicazione **asimmetrica** e **simmetrica**:\n- asimmetrica nel caso in cui il mittente nomina il destinatario ma il destinatario non nomina il mittente;\n- simetrica quando entrambi si nominano in modo esplicito.\n\n#### Modello client-server\nLe risorse del sistema sono accessibili da un singolo processo che prende il nome di processo servitore (**o server**),  e quando un processo deve utilizzarla (**processo cliente**) non può accedervi direttamente ma deve chiedere al processo server di effettuare lui stesso le operazioni desiderate sulla risorsa e di comunicargli successivamente l’esito delle elaborazioni.","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/notes/Semafori":{"title":"{{Semafori}}","content":"## Premessa\nI semafori possono essere utilizzati per gestire la mutua esclusione, garantendo che solo un processo o thread alla volta possa accedere alla risorsa condivisa. Inoltre, i semafori possono essere utilizzati per la sincronizzazione tra i processi o thread, permettendo di controllare l'ordine di esecuzione delle operazioni.\n\n## Semafori di basso livello e spinlock()\nIl primo meccanismo che analizziamo è quello che associa a ogni risorsa una variabile x o **flag**;\nIl flag fa la funzione di **semaforo**:\n- x = 1 semaforo verde, è possibile accedere alla risorsa;\n- x = 0 semaforo rosso, la risorsa è occupata ed è necessario aspettare che si liberi;\nLa variabile x semaforo può assumere solamente il valore 0 oppure 1: l’implementazione di questi semafori può essere realizzata con variabili **booleane** che prendono il nome di **spinlock**.\n\n### Allocazione di una risorsa: lock()\nLa **funzione** che permette di allocare una risorsa prende il nome di lock(). Possiamo indicare la sua sintassi nel seguente formato:\n`lock(x);`\ndove x è il **semaforo** associato alla risorsa che desideriamo utilizzare.\nQuesta funzione dovrà:\n- **testare** il semaforo per verificarne il suo **colore**;  \n- se è **verde**, modificarne il valore a **rosso**;  \n- se è **rosso**, aspettare che diventi verde per poi metterlo a **rosso**\n```\nfunzione lock(x)  \ninizia  \nripeti \nfinche x=1  \nx = 0;\nfine\n```\n\n### Rilascio di una risorsa: unlock()\nLa **funzione** che permette di rilasciare una risorsa prende il nome di unlock().  \nPossiamo indicare la sua sintassi nel seguente formato:\n`unlock(x);`\ndove x è il **semaforo** associato alla risorsa che desideriamo utilizzare.\nLa primitiva unlock() deve semplicemente modificare il valore del semaforo da rosso a verde, quindi:\n```\nfunzione unlock(x)  \ninizia  \nx = 1; \nfine\n```\nLa **mutua esclusione** si ottiene facendo precedere la **lock**(x) a una sezione critica e facendola seguire da una **unlock**(x).\n```\n...  \nlock(x);  \n\u003c sezione critica \u003e  \nunlock(x);  \n...\n```\n\n## Semaforo di Dijkstra\nDijkstra ha proposto due funzioni che permettono la soluzione di qualsiasi problema di interazione fra processi, che sono:  \n- la funzione **P**(S), che riceve in ingresso un numero intero S non negativo (**semaforo**), che viene utilizzata per accedere alla **risorsa**;  \n- la funzione **V**(S), che riceve anch’essa in ingresso un numero intero S non negativo (**semaforo**), che viene utilizzata per rilasciare la **risorsa**.\n","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]},"/notes/Sincronizzazione-tra-processi":{"title":"{{Sincronizzazione tra processi}}","content":"\n# Sincronizzazione tra processi\n\n## Errori nei programmi concorrenti\nNella programmazione concorrente possiamo riscontrare maggiori difficoltà rispetto alla programmazione sequenziale, essa infatti ci introduce la possibilità di commettere errori dipendenti dal tempo, più difficili da correggere dato che i normali debugger non hanno la capacità di controllare la correttezza temporale.\n\nEffettuare il testing di un programma concorrente è diverso rispetto ad uno sequenziale:\n- dal programma sequenziale riceviamo diversi risultati ma solo in funzione di dati di input diversi, usando casi di prova, il programmatore può verificare i comportamenti del programma mettendo a confronto gli output con i risultati previsti. Se viene accuratamente scelto l'insieme dei dati di prova, possiamo essere più certi sulla correttezza del nostro lavoro;\n- nei programmi concorrenti possono verificarsi errori legati ai tempi di esecuzione e schedulazione nella CPU i quali non possono essere determinati ed eliminati tramite il testing, ma devono invece essere evitati tramite una programmazione accurata, localizzando nel codice le parti che possono causare eventuali errori.\n\nGli errori dipendenti dal tempo sono causati da un'errata sincronizzazione dei processi, essi costituiscono una categoria di errori che possono verificarsi in corrispondenza a determinate velocità relative dei processi e non si riproducono, perciò il sistema dev'essere necessariamente riavviato con le stesse condizioni iniziali.\nLe caratteristiche degli errori dipendenti dal tempo sono:\n- irriproducibili: possono verificarsi con alcune sequenze e non con altre;  \n- indeterminati: esito ed effetti dipendono dalla sequenza;  \n- latenti: possono presentarsi solo con sequenze rare;  \n- difficili da verificare e testare: perché le tecniche di verifica e testing si basano sulla riproducibilità del comportamento.\n\nSe una risorsa è allocata come dedicata non è necessaria la sincronizzazione mentre se una risorsa è condivisa è necessario assicurare che gli accessi avvengano in modo non divisibile, ovvero le operazioni che un processo deve effettuare sulla risorsa non vengono interrotte neanche dallo scheduler ma si può garantire l'accesso in mutua esclusione fin quando il processo stesso non la rilascia al termine del suo utilizzo in modo da rendere disponibile il risultato dell'elaborazione quando questo è significativo.\n\nPer eseguire le istruzioni in modo concorrente bisogna soddisfare le condizioni di Bernstein.\n\n## Mutua esclusione e sezione critica\nSe consideriamo due processi in competizione per l’uso esclusivo di una risorsa comune, non possiamo prevedere il momento preciso nel quale uno dei processi utilizzerà la risorsa, ma dobbiamo garantire che quando ne entra in possesso lo faccia in maniera esclusiva. Ovvero la risorsa verrà utilizzata da un processo alla volta, la quale verrà rilasciata al termine delle operazioni.\n\n**Mutua esclusione**  \nSi ha mutua esclusione quando non più di un processo alla volta può accedere a una risorsa comune.\n\nLa regola di mutua esclusione impone che le operazioni con le quali i processi accedono alle variabili comuni non si sovrappongano nel tempo: inoltre nessun vincolo è imposto sull’ordine con il quale le operazioni sulle variabili vengono eseguite.\n\n**Sezione critica**\nLa sequenza di istruzioni con la quale un processo accede e modifica un insieme di variabili condivise prende il nome di sezione critica.\n\nNel modello a memoria condivisa le risorse comuni condivise saranno le variabili globali che verranno utilizzate dai diversi processi per scambiarsi informazioni.\n\n## Starvation e deadlock\nUn’errata sincronizzazione può portare al fallimento delle elaborazioni, genera situazioni di incoerenza dei dati, e può portare a situazioni di blocco dei processi: \n- starvation (o blocco individuale): si verifica quando un processo rimane in attesa di un evento che non accadrà mai, e quindi non può portare a termine il proprio lavoro;\n- deadlock (o blocco multiplo): si verifica quando due o più processi rimangono in attesa di eventi che non potranno mai verificarsi a causa di condizioni cicliche nel possesso e nella richiesta di risorse.  ","lastmodified":"2023-05-18T23:37:18.515644975Z","tags":[]}}