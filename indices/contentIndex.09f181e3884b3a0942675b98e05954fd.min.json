{"/":{"title":"Appunti TPI","content":"\n## Lista argomenti\n- [x] [[notes/Elaborazione concorrente|Elaborazione concorrente]]\n\t- [x] Generalità.\n- [x] [[notes/Descrizione della concorrenza|Descrizione della concorrenza]]:\n\t- [x] Esecuzione parallela;\n\t- [x] fork-join;\n\t- [x] cobegin-coend\n- [x] [[notes/La comunicazione tra processi|La comunicazione tra processi]]:\n\t- [x] Introduzione;\n\t- [x] Modello a memoria comune;\n\t- [x] Modello a scambio di messaggi\n- [ ] [[notes/Sincronizzazione tra processi]]:\n\t- [ ] Errori nei programmi concorrenti;\n\t- [ ] Mutua Esclusione e sezione critica;\n\t- [ ] Starvation e deadlock;\n- [ ] [[notes/Semafori]]:\n\t- [ ] Premessa;\n\t- [ ] Semafori di basso livello e spinlock;\n\t- [ ] Semaforo di Dijkstra;\n","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/New-Vault/Bancomat-Galeotto":{"title":"Bancomat Galeotto","content":"Sonja è una donna di Albuquerque, che ogni sera, tornando a casa dal lavoro, si ferma davanti al solito bancomat per prelevare 20 dollari. Una sera qualsiasi però, mentre prelevava i 20 dollari Sonja sentì una voce dietro di se che le dice di darle tutti i suoi soldi, nonostante ciò lei non fu sorpresa ma anzi se lo aspettava. Sonja aspettò che i rumori del bancomat finissero, per poi girarsi verso il rapinatore senza però guardarlo in faccia, perché aveva letto che egli poteva ucciderla essendo identificato. Sonja allora diede i soldi al rapinatore, ma egli lo fermò chiedendone altri 20, allora Sonja non resistendo alla sua voglia di guardare il rapinatore alzò lo sguardo e vide un piccolo e giovane uomo dall'aspetto cosi triste e innocente che nemmeno la canna dell'arma che puntava a Sonja dal taschino riusciva a far paura. La donna quindi, dopo la richiesta del rapinatore capì che egli non era un professionista, ma solo un ragazzo ancor più bisognoso di lei, e si rese conto anche che quella pistola che nascondeva nel taschino era solo una bottiglietta di vodka. Sonja decise quindi di non dare neanche un dollaro al rapinatore, bensì lo fece salire sulla macchina di lei, promettendogli che gli avrebbe comprato un hamburger. Si diresse quindi a un fast-food, dove mangiarono insieme un hamburger mentre parlarono. Mangiarono 20 dollari in hamburger, non per fame ma solo per parlare, lui le raccontò la sua storia banale, triste e fallimentare, Sonja gli raccontò la sua storia, ugualmente banale, triste e fallimentare. I due capirono di avere molto in comune. Dopo aver finito di mangiare, Sonja disse al rapinatore, di nome Bob di salire in macchina con lei. Chiese a Sonja dove fossero diretti, ma lei non rispose. Arrivati a destinazione, Bob fu sorpreso di trovarsi davanti a una stazione di polizia, cercò di ribellarsi ma Sonja gli disse che se sapesse cosa fare allora lei lo avrebbe aspettato. Bob allora decise di farsi arrestare, sapendo di avere un mandato di cattura per vari crimini. Dopo un solo anno Bob uscì dal carcere, sorpreso di vedere davanti al portone proprio Sonja, che lo aspettò davvero. Invitò Bob ad andare a mangiare un Hamburger, e un mese dopo già si sposarono.","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/New-Vault/TPI/Il-Cablaggio-strutturato":{"title":"Il Cablaggio strutturato","content":"Il cablaggio è la realizzazione di impianti che permettono la comunicazione\nL'impianto di comunicazione deve seguire delle norme. \nle norme che regolano il cablaggio sono le seguenti:\nLo standard EIA/TIA-568\nLo standard EIA/TIA-578\nLo standard ISO/IEC DIS \n\nLa topologia del cablaggio è di tipo gerarchico, si possono individuare tre livelli nella gerarchia:\n- Il centro stella del comprensorio detto anche MC, è unico per comprensorio;\n- Il centro stella di edificio detto IC;\n- Armadio di piano detto Telecommunication closet TC;\n\nMC è il permutatore principale situato nell'edificio principale, e da esso partono tutti i cavi di dorsale per i singoli edifici. All'interno di ogni edificio troviamo l'IC e l'armadio di distribuzione presente in ogni edificio del comprensorio e da esso vengono distribuiti i cavi di dorsale di edificio ai vari piani.\n\n","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/New-Vault/TPI/Introduzione-al-multitasking":{"title":"Introduzione al multitasking","content":"Un processo é una sequenza di istruzioni che attivano fasi di elaborazioni della cpu,fasi di attesa per l esecuzione di operazioni su altre risorse del sistema che di fatto lasciano inattiva la cpu\nnei sistemi operativi multitasking durante le fasi di attesa mandano in esecuzione altri programmi tra quelli caricati in memoria, cio riduce al minimo la non operativitá della cpu migliorando cosi l'efficienza del sistema e rendendo possibile un parallelismo tra i processi che in realta é virtuale dato che il processore é unico \nPossiamo fare una distinzione di parallalelismo in\n\n- multitasking: esecuzione di programmi indipendenti sulla CPU e sul processore di I/O\n- multiprocessing: multiprogrammazione estesa a elaboratori dotati di piu CPU e processori di I/O\n\nUn processo é costituito da due parti: \n\n- Il codice\n- I dati del programma\n\nIn particolare i dati del programma si suddividono in:\n- Variabili globali\n- Variabili locali\n- Variabili temporanee\n- Variabili allocate dinamicamente\n\nL'insieme di tutti i dati di un processo prende anche il nome di conesto del processo e varia istante per istante.\nUn processo puo stare in diversi stati \nPer stato di un processo intendiamo la situazione possibile in cui il processo in esecuzione puo trovarsi. In particolare gli stati di un processo sono:\n- Nuovo (New)\n- Esecuzione(running)\n- Attesa (Waiting)\n- Pronto (Ready to run)\n- Fine (Terminated)\nLa descrizione di questi stati avviene mediante il modello diagramma di stato","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/New-Vault/TPI/Storia-dellinternet":{"title":"Storia dell'internet","content":"Nel 1958 nasce la DARPA%%Defense Advanced Research Projects Agency %%, con sede nel Pentagono e fu applicata per ricerche nel campo della comunicazione dell'informazione.\n\n \u003e La DARPA è un agenzia governativa fondata dagli stati uniti per lo sviluppo di tecnologie ad uso militari.\n\nIntorno al 1965 la DARPA iniziava ad avere problemi di gestione per via della mancanza di comunicazione dei vari computer nelle loro sedi.\n\nNel 1966 il direttore della divisione informatica della DARPA %%Bob Taylor%% parló con Carlie Hertzfeld %%direttore della DARPA%%per fondare il progetto ARPANET. \n\nQuesto progetto sarebbe servito a condividere online il tempo di utilizzo del computer tra le diverse sedi della DARPA. \n\nNel 1969 il titolare del laboratorio della UCLA fu incaricato di creare il primo collegamento telefonico da computer a computer, fondando i primi nodi dell'internet.\n\nAd entrambi i computer fu consegnato un IMP, ovvero un computer dedicati alla gestione di traffico dati. Questi 4 nodi furono poi collegati attraverso circuiti a 50Kbps. \n\nIl primo esperimento di collegamento fu fatto dal professor Kleinrock che tentó di accedere in remoto ad un computer di Stanford. \n\n%%Digitó la lettera L, che apparí sullo schermo dell'altro computer, poi la O, che anch'essa apparí sullo schermo e infine la G che fece andare in tilt il sistema. Il secondo tentativo peró andó a buon fine.%%\n\nL'ARPANET ebbe un grande sviluppo, infatti alla fine del 72 aveva ben 37 nodi. \nNel 78, nacque poi l'IP %%Internet Protocol%%che si aggiunse al TCP per finire il protocollo TCP/IP%%TCP per la gestione di pacchetti e IP per la loro canalizzazione%%\n\n","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Descrizione-della-concorrenza":{"title":"Descrizione della concorrenza","content":"## Esecuzione parallela\nPer eseguire un processo non sequenziale c'è la necessità di utilizzare:\n- Un elaboratore non sequenziale;\n- un linguaggio di programmazione non sequenziale.\n\nL'elaboratore non sequenziale è una macchina che è in grado di eseguire più operazioni contemporaneamente. Distinguiamo tali macchine in sistemi multiprocessori o multielaboratori dove abbiamo il parallelismo fisico, e sistemi monoprocessori multiprogrammati con parallelismo virtuale.\n\nI linguaggi non sequenziali sono i linguaggi di programazione che consentono la programmazione delle attività concorrenti. Tali linguaggi concorrenti, di alto livello, implementano nuove istruzioni come i costrutti **fork-join** e **cobegin-coend**.\n\n### fork-join\nLe istruzioni fork-join servono a descrivere l'esecuzione parallela tramite la scomposizione di due processi e la riunione in un unico processo:\n- L'istruzione fork corrisponde alla biforcazione di un nodo in due rami, quindi la creazione di un processo figlio che inizia l'esecuzione in parallelo con il processo padre;\n- L'istruzione join viene eseguita quando il processo figlio termina la sua esecuzione e si sincronizza con il processo padre.\n\n### cobegin-coend\nLe istruzioni cobegin-coend permettono di indicare un punto in cui più processi iniziano contemporaneamente l'esecuzione (**cobegin**) e il punto in cui terminano, unendosi al processo principale (**coend**).\nI costrutti cobegin-coend sono più semplici da utilizzare e il codice ottenuto è più strutturato e comprensibile, dato che tramite il fork-join trasformiamo il codice in strutture simili ai vecchi linguaggi di programmazione che utilizzavano l'istruzione di salto (**goto**).","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Elaborazione-concorrente":{"title":"Elaborazione concorrente","content":"## Generalità\n### Elaborazione Sequenziale vs Elaborazione Concorrente\n\nPer elaborazione sequenziale si intende l'esecuzione di un programma sequenziale le cui istruzioni vengano eseguite una dopo l'altra in un determinato ordine, quindi un'operazione deve essere completata prima che inizi una successiva operazione. \n\nPer elaborazione concorrente intendiamo invece le tecniche e strumenti che descrivono il comportamento di processi paralleli, ovvero più processi che vengono eseguiti contemporaneamente.\n\nLa vera elaborazione concorrente si verifica solo quando si è in presenza di architetture multiprocessore, perché, come sappiamo, nei sistemi monoprocessori il parallelismo avviene virtualmente grazie al multitasking.\n\nPossiamo parlare infine di sistema concorrente, ovvero un sistema software che manda avanti l'esecuzione di più processi che possono **cooperare** ad un obiettivo comune o **competere** per utilizzare **risorse condivise**.","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/La-comunicazione-tra-processi":{"title":"La comunicazione tra processi","content":"## Introduzione\nI processi concorrenti interagiscono tra di loro condividendo risorse comuni. Possiamo individuare due modelli di interazione concorrente:\n- Modello a memoria comune;\n- Modello a scambio di messaggi.\n\n### Modello a memoria comune\nIl modello a memoria comune viene utilizzato nelle architetture che usano un' unica memoria comune a tutti i processi, come nel caso delle macchine monoprocessori con processi multitasking, inoltre, il sistema operativo associa ad ogni risorsa un gestore di risorse.\n\n### Modello a scambio di messaggi\nNel caso di un ambiente locale in cui ogni processo ha accesso solo alle risorse allocate nella propria memoria locale, i processi utilizzano lo scambio di messaggi come strumento di comunicazione e sincronizzazione. Questo modello rappresenta un sistema in cui ogni processore ha una memoria privata e opera in un ambiente locale che non è accessibile ad altri processi.\n\nIl modello a scambio di messaggi può essere classificato in vari modi:\n- nel caso di comunicazione asincrona la comunicazione da parte del processo mittente avviene senza che questo rimanga in attesa di una risposta da parte del processo destinatario;  \n- nel caso di comunicazione sincrona lo scambio di informazioni può avvenire solo se mittente e destinatario sono pronti a “parlarsi” e quindi è necessario che si sincronizzino, e questa interazione prende il nome di **rendez-vous**:\n\t- stretto: se si limita alla trasmissione di un messaggio dal mittente al destinatario;\n\t- esteso: se il destinatario, una volta ricevuto il messaggio, deve inviare una risposta al mittente.\n\nPossiamo inoltre distinguere la comunicazione **asimmetrica** e **simmetrica**:\n- asimmetrica nel caso in cui il mittente nomina il destinatario ma il destinatario non nomina il mittente;\n- simetrica quando entrambi si nominano in modo esplicito.\n\n#### Modello client-server\nLe risorse del sistema sono accessibili da un singolo processo che prende il nome di processo servitore (**o server**),  e quando un processo deve utilizzarla (**processo cliente**) non può accedervi direttamente ma deve chiedere al processo server di effettuare lui stesso le operazioni desiderate sulla risorsa e di comunicargli successivamente l’esito delle elaborazioni.","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Secondo-quadrimestre-4":{"title":"Secondo quadrimestre 4°","content":"## Lista argomenti\n- [x] [[notes/Elaborazione concorrente]]\n\t- [x] [[notes/Elaborazione concorrente#Generalità]]\n- [x] [[notes/Descrizione della concorrenza]]:\n\t- [x] [[notes/Descrizione della concorrenza#Esecuzione parallela]];\n\t- [x] [[notes/Descrizione della concorrenza#fork-join]];\n\t- [x] [[notes/Descrizione della concorrenza#cobegin-coend]];\n- [ ] [[notes/La comunicazione tra processi]]:\n\t- [ ] Introduzione;\n\t- [ ] Modello a memoria comune;\n\t- [ ] Modello a scambio di messaggi\n- [ ] [[notes/Sincronizzazione tra processi]]:\n\t- [ ] Errori nei programmi concorrenti;\n\t- [ ] Mutua Esclusione e sezione critica;\n\t- [ ] Starvation e deadlock;\n- [ ] [[notes/Semafori]]:\n\t- [ ] Premessa;\n\t- [ ] Semafori di basso livello e spinlock;\n\t- [ ] Semaforo di Dijkstra;\n","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Semafori":{"title":"Semafori","content":"","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Sincronizzazione-tra-processi":{"title":"Sincronizzazione tra processi","content":"## Errori nei programmi concorrenti\nLa programmazione concorrente nasconde maggiori insidie della normale programmazione monoprogrammata in quanto introduce la possibilità di commettere errori dipendenti dal tempo, nei confronti dei quali le normali tecniche di debugging non sono efficaci dato che, oltre alla correttezza logica, ai programmi è anche richiesta la correttezza temporale.","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]},"/notes/Test":{"title":"{{test}}","content":"","lastmodified":"2023-05-18T21:33:59.94449172Z","tags":[]}}